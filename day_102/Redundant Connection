Question:
          In this problem, a tree is an undirected graph that is connected and has no cycles.
          You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.
          Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

Test Case 1:
          Input: edges = [[1,2],[1,3],[2,3]]
          Output: [2,3]
          
Test Case 2:
          Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
          Output: [1,4]

Constraints:
          n == edges.length
          3 <= n <= 1000
          edges[i].length == 2
          1 <= ai < bi <= edges.length
          ai != bi
          There are no repeated edges.
          The given graph is connected.
          
 Logics:
          class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        UnionFind uf = new UnionFind(edges.length + 1);
        for (int[] edge : edges) {
            if (!uf.union(edge[0], edge[1]))
                return edge;
        }
        return null;
    }
}
public class UnionFind {

    int[] parent;
    int[] rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }
    public int find (int n) {
        int p = parent[n];
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    } 
    public boolean union(int n1, int n2) {
        int p1 = find(n1);
        int p2 = find(n2); 
        if (p1 == p2)
            return false;

        if (rank[p1] > rank[p2]) {
            parent[p2] = p1;
        } else if (rank[p1] < rank[p2]) {
            parent[p1] = p2;
        } else {
            parent[p2] = p1;
            rank[p1] += 1;
        }
        return true;
    }
}
